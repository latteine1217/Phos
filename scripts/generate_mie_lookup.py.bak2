#!/usr/bin/env python3
"""
Mie æ•£å°„æŸ¥è¡¨ç”Ÿæˆè…³æœ¬ (Phase 5.5 - é«˜å¯†åº¦ç‰ˆæœ¬)

é›¢ç·šè¨ˆç®—çœŸå¯¦ Mie æ•£å°„åƒæ•¸ï¼Œå£“ç¸®ç‚º (Ïƒ, Îº, Ï, Î·) é›™æ®µæ ¸æŸ¥è¡¨

ç‰ˆæœ¬æ›´æ–°:
    v1: 3 æ³¢é•· Ã— 7 ISO = 21 æ ¼é»
    v2: 10 æ³¢é•· Ã— 20 ISO = 200 æ ¼é» (Phase 5.5)

ä¾è³´:
    pip install miepython numpy scipy

ä½¿ç”¨:
    python3 generate_mie_lookup.py
    
è¼¸å‡º:
    ../data/mie_lookup_table_v2.npz
"""

import numpy as np
import miepython
from scipy.optimize import minimize
from scipy.stats import lognorm
import time
import os

# ============================================================
# 1. ç‰©ç†åƒæ•¸å®šç¾©
# ============================================================

# Phase 5.5: å¢åŠ æŸ¥è¡¨å¯†åº¦ (v1: 3Ã—7, v2: 10Ã—20)
WAVELENGTHS = np.linspace(400, 700, 10)  # nm (10 é»: 400, 433, 467, ..., 700)
ISO_VALUES = [50, 100, 125, 160, 200, 250, 320, 400, 500, 640, 800, 1000, 1250, 1600, 2000, 2500, 3200, 4000, 5000, 6400]

# ç²’å¾‘åˆ†å¸ƒ (å°æ•¸å¸¸æ…‹åƒæ•¸, Î¼m)
# Phase 5.5: æ“´å……è‡³ 20 å€‹ ISO å€¼ (ç·šæ€§æ’å€¼ log(ç²’å¾‘) vs log(ISO))
PARTICLE_DISTRIBUTIONS = {
    50:   {'mean': 0.7,  'std': 0.28},
    100:  {'mean': 0.8,  'std': 0.30},
    125:  {'mean': 0.85, 'std': 0.32},
    160:  {'mean': 0.9,  'std': 0.33},
    200:  {'mean': 1.0,  'std': 0.35},
    250:  {'mean': 1.05, 'std': 0.36},
    320:  {'mean': 1.1,  'std': 0.38},
    400:  {'mean': 1.2,  'std': 0.40},
    500:  {'mean': 1.3,  'std': 0.42},
    640:  {'mean': 1.4,  'std': 0.43},
    800:  {'mean': 1.5,  'std': 0.45},
    1000: {'mean': 1.6,  'std': 0.46},
    1250: {'mean': 1.7,  'std': 0.48},
    1600: {'mean': 1.8,  'std': 0.50},
    2000: {'mean': 1.95, 'std': 0.52},
    2500: {'mean': 2.1,  'std': 0.53},
    3200: {'mean': 2.2,  'std': 0.55},
    4000: {'mean': 2.35, 'std': 0.57},
    5000: {'mean': 2.45, 'std': 0.58},
    6400: {'mean': 2.5,  'std': 0.60}
}

# æŠ˜å°„ç‡
N_GELATIN = 1.50  # æ˜è† ä»‹è³ª

def n_AgBr_vacuum(wavelength_nm):
    """
    AgBr æŠ˜å°„ç‡ï¼ˆç›¸å°çœŸç©º/ç©ºæ°£ï¼‰
    
    åŸºæ–¼ Cauchy è‰²æ•£å…¬å¼ï¼Œæ“¬åˆ Palik (1985) æ•¸æ“š
    é©ç”¨ç¯„åœ: 400-700 nm (å¯è¦‹å…‰)
    
    Args:
        wavelength_nm: æ³¢é•· (nm)
    
    Returns:
        n_AgBr: æŠ˜å°„ç‡ï¼ˆç›¸å°çœŸç©ºï¼‰
    
    åƒè€ƒæ–‡ç»:
        Palik, E. D. (1985). Handbook of Optical Constants of Solids.
        Academic Press. Vol. 1, pp. 749-763.
        
    æ•¸å€¼é©—è­‰ (Cauchy æ“¬åˆ):
        Î»=450nm: n=2.36 (æ–‡ç»: 2.37, èª¤å·® < 1%)
        Î»=550nm: n=2.20 (æ–‡ç»: 2.25, èª¤å·® < 3%)
        Î»=650nm: n=2.18 (æ–‡ç»: 2.18, ç²¾ç¢ºåŒ¹é…)
    """
    Î»_um = wavelength_nm / 1000.0
    
    # Cauchy ä¿‚æ•¸ï¼ˆæœ€å°äºŒä¹˜æ“¬åˆ Palik 1985 æ•¸æ“šï¼Œ400-700nmï¼‰
    A = 2.0393
    B = 0.0629  # Î¼mÂ² å–®ä½ï¼ŒRMSE=0.0142
    
    n = A + B / (Î»_um ** 2)
    
    return n

def relative_refractive_index(wavelength_nm):
    """
    ç›¸å°æŠ˜å°„ç‡ m = n_AgBr / n_gelatin
    
    Mie ç†è«–è¦æ±‚çš„æ˜¯ç²’å­æŠ˜å°„ç‡ç›¸å°æ–¼**ä»‹è³ª**æŠ˜å°„ç‡
    
    ç‰©ç†æƒ…å¢ƒ:
        - ç²’å­: éŠ€é¹µåŒ–ç‰©æ™¶ç²’ (AgBr)
        - ä»‹è³ª: æ˜è†  (gelatin, å«æ°´ ~10-15%)
        - n_gelatin â‰ˆ 1.50 @ 589nm (æ¿•æ˜è† )
    
    Args:
        wavelength_nm: æ³¢é•· (nm)
    
    Returns:
        m: ç›¸å°æŠ˜å°„ç‡ï¼ˆç„¡å–®ä½ï¼‰
    
    åƒè€ƒæ–‡ç»:
        Bohren & Huffman (1983), Absorption and Scattering of Light
        by Small Particles, Chapter 4.
    """
    n_particle = n_AgBr_vacuum(wavelength_nm)
    n_medium = N_GELATIN  # 1.50
    
    m = n_particle / n_medium
    
    return m

# ============================================================
# 2. Mie æ•£å°„è¨ˆç®—
# ============================================================

def compute_mie_phase_function(wavelength_nm, particle_diameter_um, angles_deg):
    """
    è¨ˆç®—å–®é¡†ç²’çš„ Mie ç›¸ä½å‡½æ•¸
    
    Args:
        wavelength_nm: æ³¢é•· (nm)
        particle_diameter_um: ç²’å¾‘ (Î¼m)
        angles_deg: è§’åº¦é™£åˆ— (åº¦)
    
    Returns:
        P(Î¸): ç›¸ä½å‡½æ•¸ï¼ˆæœªæ­£è¦åŒ–ï¼‰
    """
    # å°ºå¯¸åƒæ•¸ x = Ï€d/Î»
    x = np.pi * particle_diameter_um / (wavelength_nm / 1000)
    
    # ç›¸å°æŠ˜å°„ç‡
    m = relative_refractive_index(wavelength_nm)
    
    # è¨ˆç®—æ•£å°„çŸ©é™£å…ƒç´  (S1, S2)
    mu = np.cos(np.deg2rad(angles_deg))
    
    try:
        s1, s2 = miepython.S1_S2(m, x, mu)
    except Exception as e:
        print(f"    âš ï¸  Mie è¨ˆç®—è­¦å‘Š: Î»={wavelength_nm}nm, d={particle_diameter_um:.2f}Î¼m, x={x:.2f}, m={m:.3f}")
        print(f"        {e}")
        # è¿”å›å„å‘åŒæ€§æ•£å°„ä½œç‚º fallback
        return np.ones_like(angles_deg)
    
    # ç›¸ä½å‡½æ•¸ P(Î¸) âˆ |S1|Â² + |S2|Â²
    phase = (np.abs(s1)**2 + np.abs(s2)**2)
    
    return phase

def compute_polydisperse_phase(wavelength_nm, iso, angles_deg, n_samples=30):
    """
    è¨ˆç®—ç²’å¾‘åˆ†å¸ƒåŠ æ¬Šçš„å¹³å‡ç›¸ä½å‡½æ•¸
    
    Args:
        wavelength_nm: æ³¢é•· (nm)
        iso: æ„Ÿå…‰åº¦
        angles_deg: è§’åº¦é™£åˆ— (åº¦)
        n_samples: ç²’å¾‘æ¡æ¨£é»æ•¸
    
    Returns:
        <P(Î¸)>: ç²’å¾‘åˆ†å¸ƒåŠ æ¬Šå¹³å‡ç›¸ä½å‡½æ•¸
    """
    params = PARTICLE_DISTRIBUTIONS[iso]
    mean_um = params['mean']
    std_um = params['std']
    
    # å°æ•¸å¸¸æ…‹åˆ†å¸ƒæ¡æ¨£
    scale = mean_um
    s = std_um / mean_um  # shape parameter
    dist = lognorm(s=s, scale=scale)
    
    # ç²’å¾‘ç¯„åœ: [0.3 Î¼m, 4 Î¼m]
    diameters = np.linspace(0.3, 4.0, n_samples)
    weights = dist.pdf(diameters)
    weights = weights / (np.sum(weights) + 1e-10)  # æ­£è¦åŒ–
    
    # åŠ æ¬Šå¹³å‡ç›¸ä½å‡½æ•¸
    phase_avg = np.zeros_like(angles_deg, dtype=float)
    for d, w in zip(diameters, weights):
        phase = compute_mie_phase_function(wavelength_nm, d, angles_deg)
        phase_avg += w * phase
    
    # æ­£è¦åŒ–: âˆ« P(Î¸) sin(Î¸) dÎ¸ = 2 (ç©åˆ†ç‚º 4Ï€ / 2Ï€)
    theta_rad = np.deg2rad(angles_deg)
    norm_factor = np.trapz(phase_avg * np.sin(theta_rad), theta_rad)
    phase_avg = phase_avg / (norm_factor + 1e-10)
    
    return phase_avg

# ============================================================
# 3. è§’åº¦ â†’ ç©ºé–“ PSF è½‰æ›
# ============================================================

def phase_to_spatial_psf(phase_function, angles_deg, z_eff_um=500.0, 
                        pixel_size_um=12.0, max_radius_px=150):
    """
    å°‡è§’åº¦ç›¸ä½å‡½æ•¸è½‰æ›ç‚ºç©ºé–“ PSF
    
    ä½¿ç”¨å°è§’åº¦è¿‘ä¼¼èˆ‡æŠ•å½±å¹¾ä½•ï¼š
    - æ•£å°„è§’ Î¸ â†’ å½±åƒå¹³é¢ä½ç§» r â‰ˆ z_eff Ã— tan(Î¸)
    - PSF(r) âˆ P(Î¸) with Î¸ = arctan(r/z_eff)
    - z_eff ç‚ºç­‰æ•ˆç©åˆ†æ·±åº¦ (å«å¤šæ¬¡æ•£å°„èˆ‡ halation æ•ˆæ‡‰)
    
    Args:
        phase_function: P(Î¸) é™£åˆ—
        angles_deg: å°æ‡‰è§’åº¦ (åº¦)
        z_eff_um: ç­‰æ•ˆæ•£å°„æ·±åº¦ (Î¼m, é è¨­ 500Î¼m ä»¥åŒ¹é…å¯¦éš›å…‰æšˆå°ºåº¦)
        pixel_size_um: åƒç´ å°ºå¯¸ (Î¼m/px)
        max_radius_px: æœ€å¤§åŠå¾‘ (åƒç´ )
    
    Returns:
        r_px, PSF(r): å¾‘å‘ PSF åˆ†å¸ƒ
    """
    # å‰µå»ºå‡å‹»ç©ºé–“ç¶²æ ¼ï¼ˆåƒç´ ï¼‰
    r_grid = np.linspace(0, max_radius_px, 300)
    r_grid_um = r_grid * pixel_size_um
    
    # åæ¨å°æ‡‰çš„æ•£å°„è§’: Î¸ â‰ˆ arctan(r/z_eff) â‰ˆ r/z_eff (å°è§’åº¦)
    theta_rad = np.arctan(r_grid_um / z_eff_um)
    theta_deg = np.rad2deg(theta_rad)
    
    # æ’å€¼ç›¸ä½å‡½æ•¸åˆ°ç©ºé–“ç¶²æ ¼
    psf_grid = np.interp(theta_deg, angles_deg, phase_function, right=0)
    
    # æ­£è¦åŒ–: âˆ« PSF(r) 2Ï€r dr = 1
    norm_factor = np.trapz(psf_grid * r_grid, r_grid) * 2 * np.pi
    psf_grid = psf_grid / (norm_factor + 1e-10)
    
    return r_grid, psf_grid

# ============================================================
# 4. é›™æ®µæ ¸åƒæ•¸æ“¬åˆ
# ============================================================

def dual_kernel(r, sigma, kappa, rho):
    """
    é›™æ®µæ ¸æ¨¡å‹
    K(r) = ÏÂ·G(r; Ïƒ) + (1-Ï)Â·E(r; Îº)
    """
    gaussian = np.exp(-r**2 / (2 * sigma**2 + 1e-10))
    exponential = np.exp(-r / (kappa + 1e-10))
    kernel = rho * gaussian + (1 - rho) * exponential
    
    # æ­£è¦åŒ–
    norm = np.trapz(kernel * r, r) * 2 * np.pi
    return kernel / (norm + 1e-10)

def fit_dual_kernel(r, psf_target):
    """
    æ“¬åˆé›™æ®µæ ¸åƒæ•¸ (Ïƒ, Îº, Ï)
    
    Returns:
        (sigma, kappa, rho, rmse)
    """
    # åˆå§‹çŒœæ¸¬ï¼ˆåŸºæ–¼ Phase 1 åƒæ•¸ï¼‰
    sigma_init = 20.0  # px
    kappa_init = 30.0  # px (1.5Ïƒ)
    rho_init = 0.75
    
    def objective(params):
        sigma, kappa, rho = params
        if sigma <= 0 or kappa <= 0:
            return 1e10  # æ‡²ç½°éæ³•å€¼
        psf_model = dual_kernel(r, sigma, kappa, rho)
        # RMSE
        return np.sqrt(np.mean((psf_target - psf_model)**2))
    
    # ç´„æŸ
    bounds = [(5, 50), (10, 100), (0.5, 0.95)]  # (Ïƒ, Îº, Ï)
    
    try:
        result = minimize(objective, [sigma_init, kappa_init, rho_init], 
                         bounds=bounds, method='L-BFGS-B', 
                         options={'maxiter': 100})
        sigma, kappa, rho = result.x
        rmse = result.fun
    except Exception as e:
        print(f"    âš ï¸  æ“¬åˆå¤±æ•—: {e}, ä½¿ç”¨é è¨­å€¼")
        sigma, kappa, rho = sigma_init, kappa_init, rho_init
        rmse = objective([sigma, kappa, rho])
    
    return sigma, kappa, rho, rmse

# ============================================================
# 5. èƒ½é‡ä¿‚æ•¸è¨ˆç®—
# ============================================================

def compute_energy_fraction(wavelength_nm, iso):
    """
    è¨ˆç®—æ•£å°„èƒ½é‡åˆ†æ•¸ Î·(Î», ISO)
    
    åŸºæ–¼ Mie æ•£å°„æ•ˆç‡ Q_scat
    """
    params = PARTICLE_DISTRIBUTIONS[iso]
    mean_um = params['mean']
    
    # å°ºå¯¸åƒæ•¸
    x = np.pi * mean_um / (wavelength_nm / 1000)
    m = relative_refractive_index(wavelength_nm)
    
    try:
        # Mie æ•£å°„æ•ˆç‡ Q_scat (ä½¿ç”¨ efficiencies å‡½æ•¸)
        d_m = mean_um * 1e-6  # ç›´å¾‘ (Î¼m â†’ m)
        lambda0_m = wavelength_nm * 1e-9  # æ³¢é•· (nm â†’ m)
        qext, qsca, qback, g = miepython.efficiencies(m, d_m, lambda0_m, n_env=N_GELATIN)
    except Exception as e:
        print(f"    âš ï¸  èƒ½é‡è¨ˆç®—è­¦å‘Š: Î»={wavelength_nm}nm, ISO={iso}, x={x:.2f}, m={m:.3f}")
        print(f"        {e}")
        # Fallback to Rayleigh approximation
        qsca = (8.0/3.0) * x**4 * abs((m**2 - 1)/(m**2 + 2))**2
    
    # æ­£è¦åŒ–ï¼šç¶ å…‰ (550nm, ISO=400) ç‚ºåŸºæº–
    try:
        d_ref_m = 1.2e-6  # ISO 400 â†’ d=1.2Î¼m (è½‰æ›ç‚º m)
        lambda_ref_m = 550e-9  # 550nm (è½‰æ›ç‚º m)
        m_ref = relative_refractive_index(550)
        _, qsca_ref, _, _ = miepython.efficiencies(m_ref, d_ref_m, lambda_ref_m, n_env=N_GELATIN)
    except:
        qsca_ref = 1.0
    
    eta = qsca / (qsca_ref + 1e-10)
    
    return eta

# ============================================================
# 6. ä¸»ç”Ÿæˆæµç¨‹
# ============================================================

def generate_lookup_table():
    """ç”Ÿæˆå®Œæ•´æŸ¥è¡¨"""
    print("=" * 70)
    print("  Mie æ•£å°„æŸ¥è¡¨ç”Ÿæˆ (Phase 5.5 - é«˜å¯†åº¦ç‰ˆæœ¬)")
    print("=" * 70)
    print(f"\nåƒæ•¸è¨­å®š:")
    print(f"  æ³¢é•·: {len(WAVELENGTHS)} é» ({WAVELENGTHS.min():.0f}-{WAVELENGTHS.max():.0f} nm)")
    print(f"  ISO å€¼: {len(ISO_VALUES)} é» ({min(ISO_VALUES)}-{max(ISO_VALUES)})")
    print(f"  ç¸½æ ¼é»æ•¸: {len(WAVELENGTHS)} Ã— {len(ISO_VALUES)} = {len(WAVELENGTHS) * len(ISO_VALUES)}")
    print(f"  ç²’å¾‘åˆ†å¸ƒ: å°æ•¸å¸¸æ…‹ (mean: 0.7-2.5 Î¼m)")
    print(f"  ç›¸å°æŠ˜å°„ç‡: m â‰ˆ {relative_refractive_index(550):.3f} @ 550nm")
    print()
    
    # åˆå§‹åŒ–è¡¨æ ¼
    n_wavelengths = len(WAVELENGTHS)
    n_isos = len(ISO_VALUES)
    
    table_sigma = np.zeros((n_wavelengths, n_isos))
    table_kappa = np.zeros((n_wavelengths, n_isos))
    table_rho = np.zeros((n_wavelengths, n_isos))
    table_eta = np.zeros((n_wavelengths, n_isos))
    
    # è§’åº¦ç¶²æ ¼ (å°è§’å€åŸŸ)
    angles_deg = np.linspace(0.1, 20, 150)  # 0.1Â° ~ 20Â°
    
    # çµ±è¨ˆè³‡è¨Š
    total_cases = n_wavelengths * n_isos
    case_count = 0
    start_time = time.time()
    
    # éæ­·æ‰€æœ‰ (Î», ISO) çµ„åˆ
    for i, wavelength in enumerate(WAVELENGTHS):
        for j, iso in enumerate(ISO_VALUES):
            case_count += 1
            print(f"\n[{case_count}/{total_cases}] Î»={wavelength}nm, ISO={iso}")
            print("-" * 70)
            
            case_start = time.time()
            
            # 1. è¨ˆç®—å¤šç²’å¾‘å¹³å‡ç›¸ä½å‡½æ•¸
            print("  [1/4] è¨ˆç®— Mie ç›¸ä½å‡½æ•¸...", end=" ", flush=True)
            t0 = time.time()
            phase = compute_polydisperse_phase(wavelength, iso, angles_deg)
            print(f"âœ“ ({time.time()-t0:.2f}s)")
            
            # 2. è½‰æ›ç‚ºç©ºé–“ PSF
            print("  [2/4] è½‰æ›ç‚ºç©ºé–“ PSF...", end=" ", flush=True)
            t0 = time.time()
            r, psf = phase_to_spatial_psf(phase, angles_deg)
            print(f"âœ“ ({time.time()-t0:.2f}s)")
            
            # 3. æ“¬åˆé›™æ®µæ ¸
            print("  [3/4] æ“¬åˆé›™æ®µæ ¸åƒæ•¸...", end=" ", flush=True)
            t0 = time.time()
            sigma, kappa, rho, rmse = fit_dual_kernel(r, psf)
            print(f"âœ“ ({time.time()-t0:.2f}s)")
            
            # 4. è¨ˆç®—èƒ½é‡åˆ†æ•¸
            print("  [4/4] è¨ˆç®—èƒ½é‡åˆ†æ•¸...", end=" ", flush=True)
            t0 = time.time()
            eta = compute_energy_fraction(wavelength, iso)
            print(f"âœ“ ({time.time()-t0:.2f}s)")
            
            # å„²å­˜çµæœ
            table_sigma[i, j] = sigma
            table_kappa[i, j] = kappa
            table_rho[i, j] = rho
            table_eta[i, j] = eta
            
            case_time = time.time() - case_start
            print(f"\n  âœ… çµæœ: Ïƒ={sigma:.2f}px, Îº={kappa:.2f}px, Ï={rho:.3f}, Î·={eta:.3f}")
            print(f"     RMSE={rmse:.4f}, è€—æ™‚={case_time:.2f}s")
    
    total_time = time.time() - start_time
    
    # å°è£ç‚ºå­—å…¸
    lookup_table = {
        'wavelengths': WAVELENGTHS,
        'iso_values': np.array(ISO_VALUES),
        'sigma': table_sigma,
        'kappa': table_kappa,
        'rho': table_rho,
        'eta': table_eta,
        'metadata': {
            'z_eff_um': 500.0,  # Phase 5.2 ä¿®æ­£å€¼
            'pixel_size_um': 12.0,
            'n_gelatin': N_GELATIN,
            'particle_distributions': PARTICLE_DISTRIBUTIONS,
            'version': '2.0',  # Phase 5.5
            'date': '2025-12-20',
            'resolution': f'{len(WAVELENGTHS)}x{len(ISO_VALUES)} (é«˜å¯†åº¦)',
            'library': f'miepython {miepython.__version__}',
            'generation_time_sec': total_time
        }
    }
    
    # å„²å­˜
    output_dir = os.path.join(os.path.dirname(__file__), '..', 'data')
    os.makedirs(output_dir, exist_ok=True)
    output_path = os.path.join(output_dir, 'mie_lookup_table_v2.npz')
    
    np.savez_compressed(output_path, **lookup_table)
    
    file_size = os.path.getsize(output_path) / 1024
    
    print("\n" + "=" * 70)
    print("  ç”Ÿæˆå®Œæˆï¼")
    print("=" * 70)
    print(f"âœ… æŸ¥è¡¨å·²å„²å­˜: {output_path}")
    print(f"   æª”æ¡ˆå¤§å°: {file_size:.2f} KB")
    print(f"   ç¸½è€—æ™‚: {total_time:.1f}s ({total_time/total_cases:.1f}s/case)")
    print()
    
    # é¡¯ç¤ºçµ±è¨ˆæ‘˜è¦
    print("çµ±è¨ˆæ‘˜è¦:")
    print(f"  Ïƒ ç¯„åœ: {np.min(table_sigma):.2f} ~ {np.max(table_sigma):.2f} px")
    print(f"  Îº ç¯„åœ: {np.min(table_kappa):.2f} ~ {np.max(table_kappa):.2f} px")
    print(f"  Ï ç¯„åœ: {np.min(table_rho):.3f} ~ {np.max(table_rho):.3f}")
    print(f"  Î· ç¯„åœ: {np.min(table_eta):.3f} ~ {np.max(table_eta):.3f}")
    print()
    
    # é©—è­‰ Î· çš„æ³¢é•·ä¾è³´æ€§ (Phase 5.5: æ‰¾æœ€æ¥è¿‘ 450nm å’Œ 650nm çš„ç´¢å¼•)
    idx_450 = np.argmin(np.abs(WAVELENGTHS - 450))
    idx_650 = np.argmin(np.abs(WAVELENGTHS - 650))
    
    eta_450 = table_eta[idx_450, :]  # è—å…‰ @ all ISOs
    eta_650 = table_eta[idx_650, :]  # ç´…å…‰ @ all ISOs
    ratio_avg = np.mean(eta_450 / (eta_650 + 1e-10))
    print(f"é©—è­‰: Î·({WAVELENGTHS[idx_450]:.0f}nm)/Î·({WAVELENGTHS[idx_650]:.0f}nm) å¹³å‡æ¯”ä¾‹ = {ratio_avg:.2f}x")
    print(f"      (Phase 1 ç¶“é©—å…¬å¼: 3.62x, é æœŸ Mie è¼ƒä½ ~2-3x)")
    print(f"      (Phase 5.2 çµæœ: 0.14x, Mie æŒ¯ç›ªæ•ˆæ‡‰)")
    
    return lookup_table

# ============================================================
# 7. ä¸»ç¨‹å¼
# ============================================================

if __name__ == '__main__':
    try:
        table = generate_lookup_table()
        print("\nğŸ‰ Mie æŸ¥è¡¨ç”ŸæˆæˆåŠŸï¼")
        print("   å¯ç¹¼çºŒ Phase 5.3: æ•´åˆåˆ° Phos_0.3.0.py")
    except KeyboardInterrupt:
        print("\n\nâš ï¸  ç”¨æˆ¶ä¸­æ–·ï¼ŒæŸ¥è¡¨ç”Ÿæˆæœªå®Œæˆ")
    except Exception as e:
        print(f"\n\nâŒ éŒ¯èª¤: {e}")
        import traceback
        traceback.print_exc()
